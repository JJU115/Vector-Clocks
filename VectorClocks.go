/*
	VectorClocks.go -  A simulation of a Vector Clocks algortithm using goroutines as processes.
	The number of processes to simulate must be specified on the command line when invoking the program
	as follows: VectorClocks <num_processes>.

	Each process will run concurrently and maintain a copy of a local "Vector clock". The number of events generated
	by each process will be a random integer between 0 and 10. Before generating an event each process will sleep for
	a random number of seconds then has a 50% chance of either experiencing an internal event or sending a message to 
	another process. Final vector timestamps for each process are printed at the end of the simulation.

	Author: Justin Underhay
	Date of last modification: Nov 1, 2018
*/

package main

import (
	"fmt"
	"math/rand"
	"os"
	"strconv"
	"sync"
	"time"
)

var numProcesses, done int
var lock sync.Mutex

var vectorChannels []chan []int
var finishChannels []chan bool 
var finalStamps []chan []int


//Each process runs this function as a goroutine, num is the process ID.
func process(num int) {
	
	var sendChan = make(chan int, 2)

	//The clockHolder function manages the process's vector stamp, receives vectors, and sends vectors
	go clockHolder(finishChannels[num], vectorChannels[num], sendChan, num)

	var dest int

	for i := 0; i < rand.Intn(10); i++ {

		time.Sleep(time.Second * time.Duration(rand.Intn(10)))

		if rand.Intn(50)%2 == 0 { //Send a special signal to the clock holder to increment
			fmt.Printf("Internal event generated by process %d\n", num)
			vectorChannels[num] <- []int{-1}

		} else { //Use the global channels array to send data to chosen process, index i = channel to index i
			dest = rand.Intn(numProcesses)
			for dest == num {
				dest = rand.Intn(numProcesses)
			}
			fmt.Printf("Process %d sending message to process %d\n", num, dest)
			sendChan <- dest
		}
	}

	//Process is finished
	lock.Lock()
	done++
	lock.Unlock()

	//If this is the last process it will signal all process clockholders to end and send
	//their process's final vector timestamps along the finalStamps channel
	if done == numProcesses {
		for k := 0; k < numProcesses; k++ {
			fmt.Println("finished")
			finishChannels[k] <- true
		}
	}
}


func clockHolder(b chan bool, receive chan []int, send chan int, num int) {
	var vectorTS = make([]int, numProcesses) //The monitered process's vector timestamp

	for {
		select {
		case vec := <-receive:
			//Received a message from another process containing vector timestamp MTS
			//Increment own clock then set the timestamp of this process as TS[k] = max(TS[k], MTS[k]) for k = 1 to numProcesses
			fmt.Println("Received vec", vec)
			vectorTS[num]++
			if vec[0] != -1 {
				for i := 0; i < numProcesses; i++ {
					if vec[i] > vectorTS[i] {
						vectorTS[i] = vec[i]
					}
				}
			}
		case dest := <-send:
			//Receiving a signal to send a vector timestamp
			fmt.Println("Received send signal to ", dest)
			vectorTS[num]++
			vectorChannels[dest] <- vectorTS
		case <-b:
			//Termination signal received, send timestamp to finalStamps channel and exit loop
			finalStamps[num] <- vectorTS
			break
		}
	}
}

func main() {

	//Get and parse command line argument(s)
	if len(os.Args) != 2 {
		fmt.Println("Invocation error. Must use executable file and invoke as: VectorClocks <num_processes>")
		os.Exit(-1)
	}

	var err error
	numProcesses, err = strconv.Atoi(os.Args[1])
	if err != nil || numProcesses < 2 {
		fmt.Println("Argument error, must be a positive integer > 2")
		os.Exit(-1)
	}

	done = 0
	vectorChannels = make([]chan []int, numProcesses)
	finishChannels = make([]chan bool, numProcesses)
	finalStamps = make([]chan []int, numProcesses)

	for i := 0; i < numProcesses; i++ {
		vectorChannels[i] = make(chan []int, 10*numProcesses)
		finishChannels[i] = make(chan bool, numProcesses)
		finalStamps[i] = make(chan []int, numProcesses)
	}

	//Run all processes
	for j := 0; j < numProcesses; j++ {
		go process(j)
	}

	//Wait until final vector stamps have been received
	for k := 0; k < numProcesses; k++ {
		fmt.Printf("Final timestamp for %d: %v\n", k, <-finalStamps[k])
	}
}
